import{B as y,e as A}from"./three.module-D2RMN07C.js";import{i as d}from"./EditorServices-BJKHmurs.js";function G(o){const n=d(o,i=>i,i=>i==null?void 0:i.isMesh,!1,!0);return n.length>0?n[0]:null}function x(o){return d(o,n=>n,n=>n==null?void 0:n.isMesh,!1,!1)}function B(o,n=!1){const i=o[0].index!==null,c=new Set(Object.keys(o[0].attributes)),g=new Set(Object.keys(o[0].morphAttributes)),f={},a={},b=o[0].morphTargetsRelative,u=new y;let m=0;for(let e=0;e<o.length;++e){const r=o[e];let s=0;if(i!==(r.index!==null))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". All geometries must have compatible attributes; make sure index attribute exists among all geometries, or in none of them."),null;for(const t in r.attributes){if(!c.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+'. All geometries must have compatible attributes; make sure "'+t+'" attribute exists among all geometries, or in none of them.'),null;f[t]===void 0&&(f[t]=[]),f[t].push(r.attributes[t]),s++}if(s!==c.size)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". Make sure all geometries have the same number of attributes."),null;if(b!==r.morphTargetsRelative)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". .morphTargetsRelative must be consistent throughout all geometries."),null;for(const t in r.morphAttributes){if(!g.has(t))return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+".  .morphAttributes must be consistent throughout all geometries."),null;a[t]===void 0&&(a[t]=[]),a[t].push(r.morphAttributes[t])}if(n){let t;if(i)t=r.index.count;else if(r.attributes.position!==void 0)t=r.attributes.position.count;else return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed with geometry at index "+e+". The geometry must have either an index or a position attribute"),null;u.addGroup(m,t,e),m+=t}}if(i){let e=0;const r=[];for(let s=0;s<o.length;++s){const t=o[s].index;for(let l=0;l<t.count;++l)r.push(t.getX(l)+e);e+=o[s].attributes.position.count}u.setIndex(r)}for(const e in f){const r=p(f[e]);if(!r)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" attribute."),null;u.setAttribute(e,r)}for(const e in a){const r=a[e][0].length;if(r===0)break;u.morphAttributes=u.morphAttributes||{},u.morphAttributes[e]=[];for(let s=0;s<r;++s){const t=[];for(let h=0;h<a[e].length;++h)t.push(a[e][h][s]);const l=p(t);if(!l)return console.error("THREE.BufferGeometryUtils: .mergeGeometries() failed while trying to merge the "+e+" morphAttribute."),null;u.morphAttributes[e].push(l)}}return u}function p(o){let n,i,c,g=-1,f=0;for(let m=0;m<o.length;++m){const e=o[m];if(n===void 0&&(n=e.array.constructor),n!==e.array.constructor)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.array must be of consistent array types across matching attributes."),null;if(i===void 0&&(i=e.itemSize),i!==e.itemSize)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.itemSize must be consistent across matching attributes."),null;if(c===void 0&&(c=e.normalized),c!==e.normalized)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.normalized must be consistent across matching attributes."),null;if(g===-1&&(g=e.gpuType),g!==e.gpuType)return console.error("THREE.BufferGeometryUtils: .mergeAttributes() failed. BufferAttribute.gpuType must be consistent across matching attributes."),null;f+=e.count*i}const a=new n(f),b=new A(a,i,c);let u=0;for(let m=0;m<o.length;++m){const e=o[m];if(e.isInterleavedBufferAttribute){const r=u/i;for(let s=0,t=e.count;s<t;s++)for(let l=0;l<i;l++){const h=e.getComponent(s,l);b.setComponent(s+r,l,h)}}else a.set(e.array,u);u+=e.count*i}return g!==void 0&&(b.gpuType=g),b}export{x as a,G as g,B as m};
