import{a as c}from"./AssetType-LSGL9ANY.js";import{F as C,i as d,D as O}from"./index--lohHrd2.js";import{g as y}from"./_commonjsHelpers-BosuxZz1.js";import{r as i}from"./index-CBqU2yxZ.js";const u={File:C,Folder:"folder",Audios:[c.MP3,"mpeg","audio/mpeg"],Images:[c.PNG,c.JPEG,"jpg","gif",c.KTX2,"image/png","image/jpeg","image/ktx2"],Models:[c.GLB,"model/glb",c.GLTF,"model/gltf",c.FBX,"model/fbx",c.USDZ,"model/usdz",c.VRM,"model/vrm"],Scripts:["tsx","ts","jsx","js","script"],Videos:[c.MP4,c.M3U8,"video/mp4",c.MKV],Volumetrics:["manifest"],Text:["text","txt"],ECS:["scene.json"],Node:"Node",Material:"Material",Lookdev:"Lookdev",Prefab:"Prefab",Component:"Component"},$=[...u.Images,...u.Audios,...u.Videos,...u.Volumetrics,...u.Models,...u.Scripts,u.Folder,u.File];var M=function r(t,e){if(t===e)return!0;if(t&&e&&typeof t=="object"&&typeof e=="object"){if(t.constructor!==e.constructor)return!1;var o,n,s;if(Array.isArray(t)){if(o=t.length,o!=e.length)return!1;for(n=o;n--!==0;)if(!r(t[n],e[n]))return!1;return!0}if(t.constructor===RegExp)return t.source===e.source&&t.flags===e.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===e.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===e.toString();if(s=Object.keys(t),o=s.length,o!==Object.keys(e).length)return!1;for(n=o;n--!==0;)if(!Object.prototype.hasOwnProperty.call(e,s[n]))return!1;for(n=o;n--!==0;){var a=s[n];if(!r(t[a],e[a]))return!1}return!0}return t!==t&&e!==e};const v=y(M),f=typeof window<"u"?i.useLayoutEffect:i.useEffect;function E(r,t,e){const[o,n]=i.useState(()=>t(r)),s=i.useCallback(()=>{const a=t(r);v(o,a)||(n(a),e&&e())},[o,r,e]);return f(s),[o,s]}function R(r,t,e){const[o,n]=E(r,t,e);return f(function(){const a=r.getHandlerId();if(a!=null)return r.subscribeToStateChange(n,{handlerIds:[a]})},[r,n]),o}function b(r,t,e){return R(t,r||(()=>({})),()=>e.reconnect())}function x(r,t){const e=[...t||[]];return t==null&&typeof r!="function"&&e.push(r),i.useMemo(()=>typeof r=="function"?r():r,e)}let h=!1;class S{receiveHandlerId(t){this.targetId=t}getHandlerId(){return this.targetId}subscribeToStateChange(t,e){return this.internalMonitor.subscribeToStateChange(t,e)}canDrop(){if(!this.targetId)return!1;d(!h,"You may not call monitor.canDrop() inside your canDrop() implementation. Read more: http://react-dnd.github.io/react-dnd/docs/api/drop-target-monitor");try{return h=!0,this.internalMonitor.canDropOnTarget(this.targetId)}finally{h=!1}}isOver(t){return this.targetId?this.internalMonitor.isOverTarget(this.targetId,t):!1}getItemType(){return this.internalMonitor.getItemType()}getItem(){return this.internalMonitor.getItem()}getDropResult(){return this.internalMonitor.getDropResult()}didDrop(){return this.internalMonitor.didDrop()}getInitialClientOffset(){return this.internalMonitor.getInitialClientOffset()}getInitialSourceClientOffset(){return this.internalMonitor.getInitialSourceClientOffset()}getSourceClientOffset(){return this.internalMonitor.getSourceClientOffset()}getClientOffset(){return this.internalMonitor.getClientOffset()}getDifferenceFromInitialOffset(){return this.internalMonitor.getDifferenceFromInitialOffset()}constructor(t){this.targetId=null,this.internalMonitor=t.getMonitor()}}function w(r,t,e){const o=e.getRegistry(),n=o.addTarget(r,t);return[n,()=>o.removeTarget(n)]}function H(r,t,e,o){let n;if(n!==void 0)return!!n;if(r===t)return!0;if(typeof r!="object"||!r||typeof t!="object"||!t)return!1;const s=Object.keys(r),a=Object.keys(t);if(s.length!==a.length)return!1;const p=Object.prototype.hasOwnProperty.bind(t);for(let l=0;l<s.length;l++){const g=s[l];if(!p(g))return!1;const D=r[g],I=t[g];if(n=void 0,n===!1||n===void 0&&D!==I)return!1}return!0}function F(r){return r!==null&&typeof r=="object"&&Object.prototype.hasOwnProperty.call(r,"current")}function j(r){if(typeof r.type=="string")return;const t=r.type.displayName||r.type.name||"the component";throw new Error(`Only native element nodes can now be passed to React DnD connectors.You can either wrap ${t} into a <div>, or turn it into a drag source or a drop target itself.`)}function k(r){return(t=null,e=null)=>{if(!i.isValidElement(t)){const s=t;return r(s,e),s}const o=t;return j(o),V(o,e?s=>r(s,e):r)}}function P(r){const t={};return Object.keys(r).forEach(e=>{const o=r[e];if(e.endsWith("Ref"))t[e]=r[e];else{const n=k(o);t[e]=()=>n}}),t}function T(r,t){typeof r=="function"?r(t):r.current=t}function V(r,t){const e=r.ref;return d(typeof e!="string","Cannot connect React DnD to an element with an existing string ref. Please convert it to use a callback ref instead, or wrap it into a <span> or <div>. Read more: https://reactjs.org/docs/refs-and-the-dom.html#callback-refs"),e?i.cloneElement(r,{ref:o=>{T(e,o),T(t,o)}}):i.cloneElement(r,{ref:t})}class L{get connectTarget(){return this.dropTarget}reconnect(){const t=this.didHandlerIdChange()||this.didDropTargetChange()||this.didOptionsChange();t&&this.disconnectDropTarget();const e=this.dropTarget;if(this.handlerId){if(!e){this.lastConnectedDropTarget=e;return}t&&(this.lastConnectedHandlerId=this.handlerId,this.lastConnectedDropTarget=e,this.lastConnectedDropTargetOptions=this.dropTargetOptions,this.unsubscribeDropTarget=this.backend.connectDropTarget(this.handlerId,e,this.dropTargetOptions))}}receiveHandlerId(t){t!==this.handlerId&&(this.handlerId=t,this.reconnect())}get dropTargetOptions(){return this.dropTargetOptionsInternal}set dropTargetOptions(t){this.dropTargetOptionsInternal=t}didHandlerIdChange(){return this.lastConnectedHandlerId!==this.handlerId}didDropTargetChange(){return this.lastConnectedDropTarget!==this.dropTarget}didOptionsChange(){return!H(this.lastConnectedDropTargetOptions,this.dropTargetOptions)}disconnectDropTarget(){this.unsubscribeDropTarget&&(this.unsubscribeDropTarget(),this.unsubscribeDropTarget=void 0)}get dropTarget(){return this.dropTargetNode||this.dropTargetRef&&this.dropTargetRef.current}clearDropTarget(){this.dropTargetRef=null,this.dropTargetNode=null}constructor(t){this.hooks=P({dropTarget:(e,o)=>{this.clearDropTarget(),this.dropTargetOptions=o,F(e)?this.dropTargetRef=e:this.dropTargetNode=e,this.reconnect()}}),this.handlerId=null,this.dropTargetRef=null,this.dropTargetOptionsInternal=null,this.lastConnectedHandlerId=null,this.lastConnectedDropTarget=null,this.lastConnectedDropTargetOptions=null,this.backend=t}}function m(){const{dragDropManager:r}=i.useContext(O);return d(r!=null,"Expected drag drop context"),r}function A(r){return i.useMemo(()=>r.hooks.dropTarget(),[r])}function N(r){const t=m(),e=i.useMemo(()=>new L(t.getBackend()),[t]);return f(()=>(e.dropTargetOptions=r||null,e.reconnect(),()=>e.disconnectDropTarget()),[r]),e}function q(){const r=m();return i.useMemo(()=>new S(r),[r])}function G(r){const{accept:t}=r;return i.useMemo(()=>(d(r.accept!=null,"accept must be defined"),Array.isArray(t)?t:[t]),[t])}class z{canDrop(){const t=this.spec,e=this.monitor;return t.canDrop?t.canDrop(e.getItem(),e):!0}hover(){const t=this.spec,e=this.monitor;t.hover&&t.hover(e.getItem(),e)}drop(){const t=this.spec,e=this.monitor;if(t.drop)return t.drop(e.getItem(),e)}constructor(t,e){this.spec=t,this.monitor=e}}function K(r,t){const e=i.useMemo(()=>new z(r,t),[t]);return i.useEffect(()=>{e.spec=r},[r]),e}function W(r,t,e){const o=m(),n=K(r,t),s=G(r);f(function(){const[p,l]=w(s,n,o);return t.receiveHandlerId(p),e.receiveHandlerId(p),l},[o,t,n,e,s.map(a=>a.toString()).join("|")])}function B(r,t){const e=x(r,t),o=q(),n=N(e.options);return W(e,o,n),[b(e.collect,o,n),A(n)]}export{u as I,$ as S,B as u};
